{ pkgs, ... }:
{
  src,
  # The name of the project, used to generate derivation names
  projectName,
  # The `package.json` for the project. It is *highly* recommended to pass this
  # in explicitly, even if it can be derived from the `src` argument. By doing
  # so, you will prevent frequent rebuilds of your generated `node_modules`
  packageJson ? "${src}/package.json",
  # The `package-lock.json` for the project. It is *highly* recommended to pass
  # this in explicitly, even if it can be derived from the `src` argument. By
  # doing so, you will prevent frequent rebuilds of your generated `node_modules`
  packageLock ? "${src}/package-lock.json",
  # The version of node to use across all project components
  nodejs ? pkgs.nodejs_22,
  # Autogenerated Nix from `spago2nix generate`
  spagoPackages ? "${src}/spago-packages.nix",
  # Extra Purescript sources to build and provide in the `devShell` as `extraSourcesDir`
  extraSources ? [ ],
  extraSourcesDir ? ".extras",
  # Data directory to add to the build and provide in the `devShell` as `dataDir`
  # E.g. [ { name = "my-data"; path = ./. ; }]
  # will be available at `data/my-data` in the `buildPursProject`s output,
  data ? [ ],
  # A directory to store `data` entries in.
  dataDir ? "data",
  # Configuration that will be used to generate a `devShell` for the project
  shell ? { },
  # Paths to submodule locations that need to be copied when constructing the NodeJS environment
  submodules ? [ ],
  ...
}:
let
  inherit (pkgs) system;

  purs = pkgs.easy-ps.purs-0_15_8;

  spagoPkgs = import spagoPackages { inherit pkgs; };

  mkNodeEnv =
    {
      withDevDeps ? true,
    }:
    import (pkgs.runCommand "node-packages-${projectName}"
      {
        buildInputs = [ pkgs.nodePackages.node2nix ];
      }
      ''
        mkdir $out
        cd $out
        cp ${packageLock} ./package-lock.json
        cp ${packageJson} ./package.json
        ${pkgs.lib.optionalString (builtins.length submodules != 0)
          "cp ${
            pkgs.linkFarm "node-packages-${projectName}-source" (
              builtins.map (path: {
                inherit path;
                name = builtins.baseNameOf (builtins.toString path);
              }) submodules
            )
          }/* . -r"
        }
        node2nix ${pkgs.lib.optionalString withDevDeps "--development"} \
          --lock ./package-lock.json -i ./package.json
      ''
    ) { inherit pkgs nodejs system; };

  mkNodeModules =
    {
      withDevDeps ? true,
    }:
    let
      nodeEnv = mkNodeEnv { inherit withDevDeps; };
      modules = pkgs.callPackage (
        _:
        nodeEnv
        // {
          shell = nodeEnv.shell.override {
            # see https://github.com/svanderburg/node2nix/issues/198
            buildInputs = [ pkgs.nodePackages.node-gyp-build ];
          };
        }
      );
    in
    (modules { }).shell.nodeDependencies;

  projectNodeModules = mkNodeModules { };

  # Constructs a development environment containing various tools to work on
  # Purescript projects. The resulting derivation can be used as a `devShell` in
  # your flake outputs
  #
  # All arguments are optional
  shellFor =
    {
      # Extra packages to include in the shell environment
      packages ? [ ],
      # Passed through to `pkgs.mkShell.inputsFrom`
      inputsFrom ? [ ],
      # Passed through to `pkgs.mkShell.shellHook`
      shellHook ? "",
      # One of `purs-tidy` or `purty` to format Purescript sources
      formatter ? "purs-tidy",
      # Whether or not to include `purescript-language-server`
      pursls ? true,
      # Generated `node_modules` in the Nix store. Can be passed to have better
      # control over individual project components
      nodeModules ? projectNodeModules,
      # If `true`, `npm i` will only write to your `package-lock.json` instead
      # of installing to a local `node_modules`
      packageLockOnly ? false,
    }:
    assert pkgs.lib.assertOneOf "formatter" formatter [
      "purs-tidy"
      "purty"
    ];
    with pkgs.lib;
    pkgs.mkShell {
      inherit packages inputsFrom;
      buildInputs = builtins.concatLists [
        [
          nodeModules
          purs
          nodejs
          pkgs.easy-ps.spago
          pkgs.easy-ps.${formatter}
          pkgs.easy-ps.pscid
          pkgs.easy-ps.psa
          pkgs.easy-ps.spago2nix
          pkgs.nodePackages.node2nix
          pkgs.unzip
          # Required to fix initdb locale issue in shell
          # https://github.com/Plutonomicon/cardano-transaction-lib/issues/828
          # Well, not really, as we set initdb locale to C for all cases now
          # Anyway, seems like it's good to have whole set of locales in the shell
          pkgs.glibcLocales
        ]

        (lists.optional pursls pkgs.easy-ps.purescript-language-server)
      ];
      shellHook = ''
        export NODE_PATH="${nodeModules}/lib/node_modules"
        ln -sfn $NODE_PATH node_modules
        export PATH="${nodeModules}/bin:$PATH"
        ${pkgs.lib.optionalString packageLockOnly "export NPM_CONFIG_PACKAGE_LOCK_ONLY=true"}
        ${linkExtraSources}
        ${linkData}
      ''
      + shellHook;
    };

  # Extra sources
  extra-sources = pkgs.linkFarm "extra-sources" (
    builtins.map (drv: {
      name = drv.name;
      path = "${drv}/src";
    }) extraSources
  );
  hasExtraSources = builtins.length extraSources > 0;
  linkExtraSources = pkgs.lib.optionalString hasExtraSources ''
    if [ -e ./${extraSourcesDir} ]; then rm ./${extraSourcesDir}; fi
    ln -s ${extra-sources} ./${extraSourcesDir}
  '';

  # Data
  data-drv = pkgs.linkFarm "data" data;
  hasData = builtins.length data > 0;
  linkData = pkgs.lib.optionalString hasData ''
    if [ -e ./${dataDir} ]; then rm ./${dataDir}; fi
    ln -s ${data-drv} ./${dataDir}
  '';

  # Compiles the dependencies of a Purescript project and copies the `output`
  # and `.spago` directories into the Nix store.
  # Intended to be used in `buildPursProject` to not recompile the entire
  # package set every time.
  buildPursDependencies =
    {
      # Can be used to override the name given to the resulting derivation
      name ? "${projectName}-ps-deps",
      # If warnings generated from project source files will trigger a build error.
      # Controls `--strict` purescript-psa flag
      strictComp ? true,
      # Warnings from `purs` to silence during compilation, independent of `strictComp`
      # Controls `--censor-codes` purescript-psa flag
      censorCodes ? [ "UserDefinedWarning" ],
      ...
    }:
    pkgs.stdenv.mkDerivation {
      inherit name;
      buildInputs = [
      ];
      nativeBuildInputs = [
        spagoPkgs.installSpagoStyle
        pkgs.easy-ps.psa
        purs
        pkgs.easy-ps.spago
      ];
      # Make the derivation independent of the source files.
      # `src` is not needed
      unpackPhase = "true";
      buildPhase = ''
        install-spago-style
        psa ${pkgs.lib.optionalString strictComp "--strict"} \
          --censor-lib \
          --is-lib=.spago ".spago/*/*/src/**/*.purs" \
          --censor-codes=${builtins.concatStringsSep "," censorCodes} \
          -gsourcemaps,js
      '';
      installPhase = ''
        mkdir $out
        mv output $out/
        mv .spago $out/
      '';
    };

  # Compiles your Purescript project and copies the `output` directory into the
  # Nix store. Also copies the local sources to be made available later as `purs`
  # does not include any external files to its `output` (if we attempted to refer
  # to absolute paths from the project-wide `src` argument, they would be wrong)
  buildPursProject =
    {
      # Can be used to override the name given to the resulting derivation
      name ? projectName,
      # Generated `node_modules` in the Nix store. Can be passed to have better
      # control over individual project components
      nodeModules ? projectNodeModules,
      # If warnings generated from project source files will trigger a build error.
      # Controls `--strict` purescript-psa flag
      strictComp ? true,
      # Warnings from `purs` to silence during compilation, independent of `strictComp`
      # Controls `--censor-codes` purescript-psa flag
      censorCodes ? [ "UserDefinedWarning" ],
      pursDependencies ? buildPursDependencies {
        inherit name strictComp censorCodes;
      },
      ...
    }:
    pkgs.stdenv.mkDerivation {
      inherit name src;
      buildInputs = [
        nodeModules
      ];
      nativeBuildInputs = [
        spagoPkgs.installSpagoStyle
        pkgs.easy-ps.psa
        purs
        pkgs.easy-ps.spago
      ];
      unpackPhase = ''
        export HOME="$TMP"
        export NODE_PATH="${nodeModules}/lib/node_modules"
        ln -sfn $NODE_PATH node_modules
        export PATH="${nodeModules}/bin:$PATH"
        ${linkExtraSources}
        ${linkData}

        # copy the dependency build artifacts and sources
        # preserve the modification date so that we don't rebuild them
        mkdir -p output .spago
        cp -rp ${pursDependencies}/.spago/* .spago
        cp -rp ${pursDependencies}/output/* output
        # note that we copy the entire source directory, not just $src/src,
        # because we need sources in ./examples and ./test
        cp -rp $src ./src

        # add write permissions for the PS compiler to use
        # `output/cache-db.json`
        chmod -R +w output/
      '';
      buildPhase = ''
        psa ${pkgs.lib.optionalString strictComp "--strict"} \
          --censor-lib \
          --is-lib=.spago ".spago/*/*/src/**/*.purs" ${pkgs.lib.optionalString hasExtraSources ''--is-lib=./${extraSourcesDir} "${extraSourcesDir}/*/**/*.purs"''} \
          --censor-codes=${builtins.concatStringsSep "," censorCodes} "./src/**/*.purs" \
          -gsourcemaps,js
      '';
      # We also need to copy all of `src` here, since compiled modules in `output`
      # might refer to paths that will point to nothing if we use `src` directly
      # in other derivations (e.g. when using `fs.readFileSync` inside an FFI
      # module)
      installPhase = ''
        mkdir $out
        cp -r output $out/
        ${pkgs.lib.optionalString hasExtraSources ''cp -r ./${extraSourcesDir} $out/''}
        ${pkgs.lib.optionalString hasData ''cp -r ./${dataDir} $out/''}
      '';
    };

  # Runs a test written in Purescript using NodeJS.
  runPursTest =
    {
      # The main Purescript module
      testMain,
      # The entry point function in the main PureScript module
      psEntryPoint ? "main",
      # Can be used to override the name of the resulting derivation
      name ? "${projectName}-check",
      # Generated `node_modules` in the Nix store. Can be passed to have better
      # control over individual project components
      nodeModules ? projectNodeModules,
      # Additional variables to pass to the test environment
      env ? { },
      # Passed through to the `buildInputs` of the derivation. Use this to add
      # additional packages to the test environment
      buildInputs ? [ ],
      builtProject ? buildPursProject { main = testMain; },
      ...
    }:
    pkgs.runCommand "${name}"
      (
        {
          inherit src;
          nativeBuildInputs = [
            builtProject
            nodeModules
          ]
          ++ buildInputs;
          NODE_PATH = "${nodeModules}/lib/node_modules";
        }
        // env
      )
      ''
        # Copy the purescript project files
        cp -r ${builtProject}/* .

        # The tests may depend on sources
        cp -r $src/* .

        # Provide NPM dependencies to the test suite scripts
        ln -sfn ${nodeModules}/lib/node_modules node_modules

        # This line fixes an issue where the hedgehog output generated by cardano-testnet
        # was not being handled, making it impossible to extract cardano-testnet
        # workspace information and thus causing cluster initialization to fail.
        # see https://github.com/hedgehogqa/haskell-hedgehog/issues/110
        export LC_ALL=C.UTF-8

        # Call the main module and execute the entry point function
        ${nodejs}/bin/node --enable-source-maps -e 'import("./output/${testMain}/index.js").then(m => m.${psEntryPoint}())'

        # Create output file to tell Nix we succeeded
        touch $out
      '';

  # Bundles a Purescript project using esbuild, typically for the browser
  bundlePursProjectEsbuild =
    {
      # Can be used to override the name given to the resulting derivation
      name ? "${projectName}-bundle-" + (if browserRuntime then "web" else "nodejs"),
      # The main Purescript module
      main,
      # The entry point function in the main PureScript module
      psEntryPoint ? "main",
      # Whether this bundle is being produced for a browser environment or not
      browserRuntime ? true,
      esbuildBundleScript ? "esbuild/bundle.js",
      # Generated `node_modules` in the Nix store. Can be passed to have better
      # control over individual project components
      nodeModules ? projectNodeModules,
      builtProject ? buildPursProject { inherit main; },
      ...
    }:
    pkgs.runCommand "${name}"
      {
        inherit src;
        buildInputs = [
          nodejs
          nodeModules
        ];
        nativeBuildInputs = [
          purs
          pkgs.easy-ps.spago
          builtProject
        ];
      }
      ''
        export HOME="$TMP"
        export NODE_PATH="${nodeModules}/lib/node_modules"
        ln -sfn $NODE_PATH node_modules
        export PATH="${nodeModules}/bin:$PATH"
        ${pkgs.lib.optionalString browserRuntime "export BROWSER_RUNTIME=1"}
        cp -r ${builtProject}/* .
        cp -r $src/* .
        chmod -R +rw .
        echo 'import("./output/${main}/index.js").then(m => m.${psEntryPoint}());' > entrypoint.js
        mkdir $out
        node ${esbuildBundleScript} ./entrypoint.js $out/index.js
      '';

  # Bundles a Purescript project using Webpack, typically for the browser
  bundlePursProjectWebpack =
    {
      # Can be used to override the name given to the resulting derivation
      name ? "${projectName}-bundle-" + (if browserRuntime then "web" else "nodejs"),
      # The main Purescript module
      main,
      # The entry point function in the main PureScript module
      psEntryPoint ? "main",
      # If this bundle is being produced for a browser environment or not
      browserRuntime ? true,
      # Path to the Webpack config to use
      webpackConfig ? "webpack.config.cjs",
      # The name of the bundled JS module that `spago bundle-module` will produce
      bundledModuleName ? "output.js",
      # Generated `node_modules` in the Nix store. Can be passed to have better
      # control over individual project components
      nodeModules ? projectNodeModules,
      # If the spago bundle-module output should be included in the derivation
      includeBundledModule ? false,
      builtProject ? buildPursProject { inherit main; },
      ...
    }:
    pkgs.runCommand "${name}"
      {
        inherit src;
        buildInputs = [
        ];
        nativeBuildInputs = [
          nodejs
          nodeModules
          builtProject
          purs
          pkgs.easy-ps.spago
        ];
      }
      ''
        export HOME="$TMP"
        export NODE_PATH="${nodeModules}/lib/node_modules"
        export PATH="${nodeModules}/bin:$PATH"
        ${pkgs.lib.optionalString browserRuntime "export BROWSER_RUNTIME=1"}
        cp -r ${builtProject}/* .
        cp -r $src/* .
        chmod -R +rw .
        mkdir -p ./dist
        echo 'import("./output/${main}/index.js").then(m => m.${psEntryPoint}());' > entrypoint.js
        ${pkgs.lib.optionalString includeBundledModule "cp ${bundledModuleName} ./dist"}
        mkdir $out
        webpack --mode=production -c ${webpackConfig} -o $out/ \
          --entry ./entrypoint.js
      '';

  buildPursDocs =
    {
      name ? "${projectName}-docs",
      format ? "html",
      ...
    }@args:
    (buildPursProject (args // { strictComp = false; })).overrideAttrs (_: {
      inherit name;
      buildPhase = ''
        purs docs --format ${format} "./src/**/*.purs" ".spago/*/*/src/**/*.purs" ${pkgs.lib.optionalString hasExtraSources ''"${extraSourcesDir}/*/**/*.purs"''}
      '';
      installPhase = ''
        mkdir $out
        cp -r generated-docs $out
        cp -r output $out
      '';
    });

in
{
  inherit
    buildPursProject
    buildPursDependencies
    runPursTest
    bundlePursProjectEsbuild
    bundlePursProjectWebpack
    buildPursDocs
    # TODO: restore buildSearchablePursDocs and launchSearchablePursDocs
    # https://github.com/Plutonomicon/cardano-transaction-lib/issues/1578
    purs
    nodejs
    mkNodeModules
    ;
  devShell = shellFor shell;
  compiled = buildPursProject { };
  nodeModules = projectNodeModules;
}
